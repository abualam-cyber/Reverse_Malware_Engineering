#include <fstream>
#include <iostream>
#include <iomanip>
#include <stdexcept>
#include <vector>
#include <algorithm>
#include <memory>
#include <boost/program_options.hpp>
#include <tbb/task_scheduler_init.h>
#include <tbb/parallel_for.h>
#include <tbb/blocked_range.h>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/basic_file_sink.h>
#include <spdlog/sinks/stdout_color_sinks.h>
#include <capstone/capstone.h>
#include <filesystem> // Cross-platform file system library
#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif

// SPECIFIES THE SIZE OF EACH CHINK OF CODE TO BE PROCESSED IN PARALLEL
constexpr size_t CHUNK_SIZE = 1024 * 1024; 

// DISASSEMBLER CLASS IS RESPONSIBLE FOR READING BINARU FILES, DISASSEMBLING CODE CHUNKS, AND LOGGING THE DISASSEMBLED INSTRUCTIONS
class Disassembler {
// FUNCTION TO READ THE CONTENTS OF A BINARY FILE INTO A VECTOR OF BYTES
public:
    static std::vector<uint8_t> readFile(const std::string& filename) {
        std::ifstream file(filename, std::ios::ate | std::ios::binary);

        if (!file.is_open()) {
            throw std::runtime_error("Failed to open file: " + filename);
        }

        size_t fileSize = file.tellg();
        std::vector<uint8_t> buffer(fileSize);
        file.seekg(0);
        file.read(reinterpret_cast<char*>(&buffer[0]), fileSize);

        if (file.bad()) {
            throw std::runtime_error("Error reading file: " + filename);
        }

        return buffer;
    }
// FUNCTION TO DISASSEMBLE A CHUNK OF BINARY CODE USING CAPSTONE AND STORES THE DISASSEMBLED INSTRUCTION IN A VECTOR OF STRINGS
    static void disassembleChunk(const std::vector<uint8_t>& code, size_t start, size_t end, std::vector<std::string>& output, cs_arch arch, cs_mode mode, const cs_opt* opts) {
        std::unique_ptr<csh, void(*)(csh*)> handle(cs_open(arch, mode, opts), cs_close);
        cs_insn *insn;
        size_t count;

        if (!handle) {
            spdlog::error("Failed to initialize Capstone");
            return;
        }

        count = cs_disasm(handle.get(), &code[start], end - start, start, 0, &insn);
        if (count > 0) {
            for (size_t i = 0; i < count; ++i) {
                std::stringstream ss;
                ss << std::hex << std::setw(8) << std::setfill('0') << insn[i].address << ": ";
                ss << insn[i].mnemonic << " " << insn[i].op_str;
                output.push_back(ss.str());
            }
            cs_free(insn, count);
        } else {
            spdlog::error("Failed to disassemble code chunk at offset: " + std::to_string(start));
        }
    }

// FUNCTION TO DISASSEMBLES THE ENTIRE CODE IN PARALLEL BY DIVIDING IT INTO CHUNKS AND PROCESSING EACH CHUNK INDEPENDENTLY USING TBB. IT ALSO LOGS THE DISASSEMBLED INSTRUCTIONS
    static void parallelDisassemble(const std::vector<uint8_t>& code, const std::string& logFilename, const std::string& logType, cs_arch arch, cs_mode mode, const cs_opt* opts) {
        std::vector<std::string> output;
        output.reserve(code.size() / 16);

        tbb::task_scheduler_init init(std::thread::hardware_concurrency());

        size_t chunkSize = std::min(CHUNK_SIZE, std::max(size_t(1), code.size() / init.max_thread_count()));

        auto logger = getLogger(logType, logFilename); // CREATE A LOGGER INSTANCE FOR LOGGING DISASSEMBLE OUTPUT TO BOTH A FILE AND THE CONSOLE

        tbb::parallel_for(tbb::blocked_range<size_t>(0, code.size(), chunkSize), [&](const tbb::blocked_range<size_t>& range) {
            std::vector<std::string> chunkOutput;
            disassembleChunk(code, range.begin(), range.end(), chunkOutput, arch, mode, opts);
            logger->info("Processed chunk at offset: {}", range.begin());
            for (const auto& instruction : chunkOutput) {
                logger->info("{}", instruction);
            }
        });
    }

private:
    static std::shared_ptr<spdlog::logger> getLogger(const std::string& logType, const std::string& logFilename) {
        auto consoleSink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
        consoleSink->set_level(spdlog::level::info);

        std::shared_ptr<spdlog::sinks::sink> fileSink;
        if (logType == "txt") {
            fileSink = std::make_shared<spdlog::sinks::basic_file_sink_mt>(logFilename, true);
        } else if (logType == "json") {
            fileSink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(logFilename, 1024 * 1024, 5, true);
        } else {
            throw std::invalid_argument("Invalid log type: " + logType);
        }

        fileSink->set_level(spdlog::level::info);

        auto logger = std::make_shared<spdlog::logger>("logger", fileSink, consoleSink);
        logger->set_level(spdlog::level::info);
        return logger;
    }
};
// CLASS TO PARSE COMMAND LINE ARGUMENTS USING BOOST PROGRAM OPTIONS AND PROVIDES METHODS TOACCESS THE PARSED VALUES
class CommandLineParser {
public:
    CommandLineParser(int argc, char** argv) : argc(argc), argv(argv) {}

    std::string getInputFile() const {
        return inputFilename;
    }

    std::string getLogFilename() const {
        return logFilename;
    }

    std::string getLogType() const {
        return logType;
    }

    cs_arch getArch() const {
        return arch;
    }

    cs_mode getMode() const {
        return mode;
    }

    const cs_opt* getOptions() const {
        return &opts;
    }
// FUNCTION TO PARSE COMMAND LINE ARGUMENTS, VALIDATE THEM, AND SET THE CORRESPONDING FIELDS IN THE CLASS INSTANCE
    void parse() {
        try {
            namespace po = boost::program_options;
            po::options_description desc("Allowed options");
            desc.add_options()
                ("help", "produce help message")
                ("input-file", po::value<std::string>(&inputFilename)->required(), "input binary file")
                ("log-file", po::value<std::string>(&logFilename)->required(), "log file")
                ("log-type", po::value<std::string>(&logType)->required(), "log type: txt, json, console")
                ("arch", po::value<std::string>(&archString)->required(), "architecture: x86, x86_64, arm, arm64")
                ("mode", po::value<int>(&modeInt)->default_value(32), "mode: 32 or 64")
                ("options", po::value<std::string>(&options)->default_value(""), "disassembly options");

            po::variables_map vm;
            po::store(po::parse_command_line(argc, argv, desc), vm);

            if (vm.count("help")) {
                std::cout << desc << std::endl;
                exit(0);
            }

            po::notify(vm);

            if (archString == "x86") {
                arch = CS_ARCH_X86;
            } else if (archString == "x86_64") {
                arch = CS_ARCH_X86;
                mode = CS_MODE_64;
            } else if (archString == "arm") {
                arch = CS_ARCH_ARM;
                mode = CS_MODE_ARM;
            } else if (archString == "arm64") {
                arch = CS_ARCH_ARM64;
                mode = CS_MODE_ARM;
            } else {
                throw std::invalid_argument("Invalid architecture");
            }

            if (modeInt == 32) {
                mode = CS_MODE_32;
            } else if (modeInt == 64) {
                mode = CS_MODE_64;
            } else {
                throw std::invalid_argument("Invalid mode");
            }

            if (!options.empty()) {
                std::istringstream iss(options);
                std::string token;
                while (std::getline(iss, token, ',')) {
                    if (token == "syntax_only") {
                        opts.syntax_only = 1;
                    } else if (token == "skip_data") {
                        opts.skip_data = 1;
                    } else if (token == "detail") {
                        opts.detail = 1;
                    } else {
                        throw std::invalid_argument("Invalid option: " + token);
                    }
                }
            }

            if (!std::ifstream(inputFilename).is_open()) {
                throw std::runtime_error("Input file does not exist or is not accessible: " + inputFilename);
            }

            if (!std::ofstream(logFilename).is_open()) {
                throw std::runtime_error("Log file does not exist or is not accessible: " + logFilename);
            }
        } catch (std::exception& e) {
            std::cerr << "Error: " << e.what() << std::endl;
            exit(1);
        }
    }

private:
    int argc;
    char** argv;
    std::string inputFilename;
    std::string logFilename;
    std::string logType;
    std::string archString;
    int modeInt;
    std::string options;
    cs_arch arch = CS_ARCH_X86;
    cs_mode mode = CS_MODE_32;
    cs_opt opts = {};
};
// MAIN FUNCTION
int main(int argc, char** argv) {
    CommandLineParser parser(argc, argv); 
    parser.parse();

    try {
        auto code = Disassembler::readFile(parser.getInputFile());
        Disassembler::parallelDisassemble(code, parser.getLogFilename(), parser.getLogType(), parser.getArch(), parser.getMode(), parser.getOptions());
    } catch (std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
